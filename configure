#!/bin/bash

# Purely modern configure script - no legacy tool downloads
# Uses system tools and Conan tool_requires

set -e  # Exit on any error

# Source constants and utility functions
chmod +x scripts/constants.sh
source scripts/constants.sh

# Enhanced utility functions
check_command() {
    if ! command -v "$1" &> /dev/null; then
        print_error "$1 is not installed or not in PATH"
        return 1
    fi
    return 0
}

install_python_dependencies() {
    print_header "Installing Python Dependencies"
    
    local python_cmd="python3"
    command_exists python3 || python_cmd="python"
    
    local pip_cmd="pip3"  
    command_exists pip3 || pip_cmd="pip"
    
    # Check if packaging is already installed
    if $python_cmd -c "import packaging" 2>/dev/null; then
        print_status "Python packaging library already installed ✓"
    else
        print_step "Installing Python packaging library..."
        if $pip_cmd install packaging; then
            print_success "Python packaging library installed ✓"
        else
            print_error "Failed to install packaging library"
            print_status "This is required for proper version comparison in conanfile.py"
            exit 1
        fi
    fi
    
    # Install Conan if needed
    if ! check_command "conan"; then
        print_step "Installing Conan package manager..."
        $pip_cmd install "conan>=2.0" || {
            print_error "Failed to install Conan"
            exit 1
        }
        print_success "Conan package manager installed ✓"
    fi
}

setup_cpp_standard_utility() {
    print_header "Setting Up C++ Standard Utility"
    
    # Create scripts directory if it doesn't exist
    mkdir -p scripts
    
    # Create the cpp_standard.sh script
    print_status "Creating C++ standard utility script..."
    
    cat > scripts/cpp_standard.sh << 'EOF'
#!/bin/bash

# C++ Standard Selection and Configuration Utility
# Auto-generated by cpp-conan-template configure script

set -e

# Source constants if available
if [ -f "scripts/constants.sh" ]; then
    source scripts/constants.sh
else
    # Basic fallback functions
    print_status() { echo "[INFO] $1"; }
    print_error() { echo "[ERROR] $1" >&2; }
    print_warning() { echo "[WARNING] $1"; }
    print_success() { echo "[SUCCESS] $1"; }
    print_header() { echo -e "\n=== $1 ==="; }
fi

# C++ standard information database
declare -A CPP_STANDARDS=(
    ["17"]="C++17 (ISO/IEC 14882:2017)"
    ["20"]="C++20 (ISO/IEC 14882:2020)"
    ["23"]="C++23 (ISO/IEC 14882:2023)"
    ["26"]="C++26 (Planned for 2026)"
)

declare -A CPP_FEATURES=(
    ["17"]="structured_bindings,if_constexpr,fold_expressions,parallel_algorithms"
    ["20"]="concepts,coroutines,modules,ranges,three_way_comparison,consteval"
    ["23"]="deducing_this,multidimensional_subscript,explicit_this,static_call_operator"
    ["26"]="reflection,networking,pattern_matching,contracts"
)

declare -A COMPILER_SUPPORT=(
    ["17"]="GCC 7+, Clang 5+, MSVC 19.14+ (VS 2017 15.7)"
    ["20"]="GCC 10+, Clang 12+, MSVC 19.29+ (VS 2019 16.10)"
    ["23"]="GCC 11+, Clang 14+, MSVC 19.33+ (VS 2022 17.3)"
    ["26"]="GCC 13+, Clang 16+, MSVC 19.40+ (VS 2022 17.10)"
)

show_standard_info() {
    local std="$1"
    
    if [[ -z "${CPP_STANDARDS[$std]}" ]]; then
        print_error "Unsupported C++ standard: $std"
        return 1
    fi
    
    print_header "C++$std Information"
    echo "Standard: ${CPP_STANDARDS[$std]}"
    echo "Compiler Support: ${COMPILER_SUPPORT[$std]}"
    echo ""
    
    echo "Key Features:"
    IFS=',' read -ra FEATURES <<< "${CPP_FEATURES[$std]}"
    for feature in "${FEATURES[@]}"; do
        echo "  • $(echo "$feature" | tr '_' ' ')"
    done
    echo ""
}

check_compiler_support() {
    local std="$1"
    local compiler_found=false
    
    print_header "Checking Compiler Support for C++$std"
    
    # Check GCC
    if command -v gcc >/dev/null 2>&1; then
        local gcc_version=$(gcc -dumpversion | cut -d. -f1)
        local required_gcc=""
        
        case "$std" in
            "17") required_gcc="7" ;;
            "20") required_gcc="10" ;;
            "23") required_gcc="11" ;;
            "26") required_gcc="13" ;;
        esac
        
        if [ "$gcc_version" -ge "$required_gcc" ] 2>/dev/null; then
            print_success "GCC $gcc_version supports C++$std ✓"
            compiler_found=true
        else
            print_warning "GCC $gcc_version - requires GCC $required_gcc+ for C++$std"
        fi
    fi
    
    # Check Clang
    if command -v clang >/dev/null 2>&1; then
        local clang_version=$(clang --version | grep -oE '[0-9]+\.[0-9]+' | head -1 | cut -d. -f1)
        local required_clang=""
        
        case "$std" in
            "17") required_clang="5" ;;
            "20") required_clang="12" ;;
            "23") required_clang="14" ;;
            "26") required_clang="16" ;;
        esac
        
        if [ "$clang_version" -ge "$required_clang" ] 2>/dev/null; then
            print_success "Clang $clang_version supports C++$std ✓"
            compiler_found=true
        else
            print_warning "Clang $clang_version - requires Clang $required_clang+ for C++$std"
        fi
    fi
    
    # Check MSVC (if available)
    if command -v cl >/dev/null 2>&1; then
        print_status "MSVC detected - check Visual Studio version manually"
        print_status "Required: ${COMPILER_SUPPORT[$std]}"
        compiler_found=true
    fi
    
    if ! $compiler_found; then
        print_error "No suitable compiler found for C++$std"
        print_status "Install one of: ${COMPILER_SUPPORT[$std]}"
        return 1
    fi
    
    return 0
}

set_cpp_standard() {
    local std="$1"
    
    if [[ -z "${CPP_STANDARDS[$std]}" ]]; then
        print_error "Unsupported C++ standard: $std"
        print_status "Supported standards: ${!CPP_STANDARDS[*]}"
        return 1
    fi
    
    print_header "Setting C++ Standard to C++$std"
    
    # Check compiler support first
    if ! check_compiler_support "$std"; then
        print_error "Cannot set C++$std - compiler requirements not met"
        return 1
    fi
    
    # Update conanfile.py
    if [ -f "conanfile.py" ]; then
        print_status "Updating conanfile.py default C++ standard..."
        
        # Create backup
        cp conanfile.py conanfile.py.bak
        
        # Update the default_options
        sed -i.tmp "s/\"cxx_standard\": \"[0-9]*\"/\"cxx_standard\": \"$std\"/g" conanfile.py && rm -f conanfile.py.tmp
        
        print_success "Updated conanfile.py default C++ standard to C++$std"
    fi
    
    # Update CMakeLists.txt
    if [ -f "CMakeLists.txt" ]; then
        print_status "Updating CMakeLists.txt default C++ standard..."
        
        # Create backup
        cp CMakeLists.txt CMakeLists.txt.bak
        
        # Update CMAKE_CXX_STANDARD
        sed -i.tmp "s/set(CMAKE_CXX_STANDARD [0-9]*)/set(CMAKE_CXX_STANDARD $std)/g" CMakeLists.txt && rm -f CMakeLists.txt.tmp
        
        print_success "Updated CMakeLists.txt default C++ standard to C++$std"
    fi
    
    # Create .cppstd file for easy reference
    echo "$std" > .cppstd
    print_status "Created .cppstd file with current standard: C++$std"
    
    print_success "C++ standard set to C++$std"
    print_status ""
    print_status "Next steps:"
    print_status "1. Run: ./configure clean"
    print_status "2. Run: ./configure"
    print_status "3. Run: ./make"
    
    show_standard_info "$std"
}

show_current_standard() {
    print_header "Current C++ Standard Configuration"
    
    # Check .cppstd file
    if [ -f ".cppstd" ]; then
        local current_std=$(cat .cppstd)
        print_status "Configured standard: C++$current_std"
        show_standard_info "$current_std"
    fi
    
    # Check conanfile.py
    if [ -f "conanfile.py" ]; then
        local conan_std=$(grep -o '"cxx_standard": "[0-9]*"' conanfile.py | grep -o '[0-9]*' || echo "not set")
        print_status "conanfile.py standard: C++$conan_std"
    fi
    
    # Check CMakeLists.txt
    if [ -f "CMakeLists.txt" ]; then
        local cmake_std=$(grep -o 'CMAKE_CXX_STANDARD [0-9]*' CMakeLists.txt | grep -o '[0-9]*' || echo "not set")
        print_status "CMakeLists.txt standard: C++$cmake_std"
    fi
}

build_with_standard() {
    local std="$1"
    
    print_header "Building with C++$std"
    
    # Set environment variable for this build
    export CXX_STANDARD="$std"
    
    # Build with specified standard
    print_status "Building with C++$std (temporary override)..."
    
    if [ -f "./make" ]; then
        CXX_STANDARD="$std" ./make
    else
        print_error "Make script not found"
        return 1
    fi
}

show_help() {
    print_header "C++ Standard Utility Help"
    echo "Usage: $0 [COMMAND] [OPTIONS]"
    echo ""
    echo "Commands:"
    echo "  set <std>     Set C++ standard (17, 20, 23, 26)"
    echo "  info <std>    Show information about C++ standard"
    echo "  check <std>   Check compiler support for standard"
    echo "  current       Show current configuration"
    echo "  build <std>   Build with specific standard (temporary)"
    echo "  list          List all supported standards"
    echo ""
    echo "Options:"
    echo "  --help, -h    Show this help"
    echo ""
    echo "Examples:"
    echo "  $0 set 20           # Set project to C++20"
    echo "  $0 info 23          # Show C++23 information"
    echo "  $0 check 26         # Check C++26 compiler support"
    echo "  $0 build 17         # Build temporarily with C++17"
    echo "  $0 current          # Show current configuration"
}

list_standards() {
    print_header "Supported C++ Standards"
    
    for std in "${!CPP_STANDARDS[@]}"; do
        echo "C++$std: ${CPP_STANDARDS[$std]}"
    done | sort -V
    
    echo ""
    print_status "Use '$0 info <standard>' for detailed information"
}

# Main script logic
case "${1:-}" in
    "set")
        if [ -z "$2" ]; then
            print_error "Please specify a C++ standard"
            show_help
            exit 1
        fi
        set_cpp_standard "$2"
        ;;
    "info")
        if [ -z "$2" ]; then
            print_error "Please specify a C++ standard"
            show_help
            exit 1
        fi
        show_standard_info "$2"
        ;;
    "check")
        if [ -z "$2" ]; then
            print_error "Please specify a C++ standard"
            show_help
            exit 1
        fi
        check_compiler_support "$2"
        ;;
    "current")
        show_current_standard
        ;;
	"build")
        if [ -z "$2" ]; then
            print_error "Please specify a C++ standard"
            show_help
            exit 1
        fi
        build_with_standard "$2"
        ;;
    "list")
        list_standards
        ;;
    "--help"|"-h"|"help")
        show_help
        ;;
    "")
        # No arguments - show current status
        show_current_standard
        ;;
    *)
        # Try to interpret as a standard number
        if [[ "$1" =~ ^[0-9]+$ ]] && [[ -n "${CPP_STANDARDS[$1]}" ]]; then
            set_cpp_standard "$1"
        else
            print_error "Unknown command: $1"
            show_help
            exit 1
        fi
        ;;
esac
EOF

    # Make the script executable
    chmod +x scripts/cpp_standard.sh
    print_success "C++ standard utility script created and made executable ✓"
}

update_template_files() {
    print_header "Updating Template Files with Enhanced C++ Support"
    
    # Backup existing files
    [ -f "conanfile.py" ] && cp conanfile.py conanfile.py.backup
    [ -f "CMakeLists.txt" ] && cp CMakeLists.txt CMakeLists.txt.backup
    
    # Update conanfile.py with enhanced version
    print_status "Updating conanfile.py with enhanced C++ standard support..."
    
    cat > conanfile.py << 'EOF'
from conan import ConanFile
from conan.tools.cmake import CMakeToolchain, CMakeDeps, cmake_layout
from conan.tools.files import copy
from conan.errors import ConanInvalidConfiguration
from packaging import version
import os

class CppConanTemplateConan(ConanFile):
    name = "cpp-conan-template"
    version = "1.0.0"
    package_type = "application"
    
    # Binary configuration
    settings = "os", "compiler", "build_type", "arch"
    options = {
        "shared": [True, False],
        "fPIC": [True, False],
        "cxx_standard": ["17", "20", "23", "26"]  # Support future standards
    }
    default_options = {
        "shared": False,
        "fPIC": True,
        "cxx_standard": "20"  # Default to C++20
    }
    
    # Package metadata
    description = "Modern C++ project template with Conan 2.0"
    topics = ("cpp", "template", "conan")
    url = "https://github.com/yourusername/cpp-conan-template"
    license = "MIT"
    
    def _get_min_compiler_version(self, cxx_std):
        """Get minimum compiler versions required for each C++ standard"""
        requirements = {
            "17": {
                "gcc": "7",
                "clang": "5", 
                "msvc": "191",  # VS 2017
                "apple-clang": "9.1"
            },
            "20": {
                "gcc": "10",      # GCC 10 has good C++20 support
                "clang": "12",    # Clang 12 has good C++20 support  
                "msvc": "192",    # VS 2019 16.0
                "apple-clang": "12"
            },
            "23": {
                "gcc": "11",      # GCC 11+ for C++23 features
                "clang": "14",    # Clang 14+ for C++23
                "msvc": "193",    # VS 2022
                "apple-clang": "14"
            },
            "26": {
                "gcc": "13",      # Future-proofing for C++26
                "clang": "16",    # Future estimates
                "msvc": "194",    # Future VS version
                "apple-clang": "15"
            }
        }
        return requirements.get(str(cxx_std), requirements["20"])
    
    def _check_compiler_support(self, compiler_name, compiler_version, cxx_std):
        """Check if compiler version supports the requested C++ standard"""
        min_versions = self._get_min_compiler_version(cxx_std)
        min_version = min_versions.get(compiler_name)
        
        if not min_version:
            self.output.warn(f"Unknown compiler {compiler_name}, skipping version check")
            return True
            
        try:
            return version.parse(str(compiler_version)) >= version.parse(min_version)
        except Exception as e:
            self.output.warn(f"Could not parse version {compiler_version}: {e}")
            return True  # Be permissive if we can't parse
    
    def _determine_cxx_standard(self):
        """Determine the C++ standard to use based on options and compiler settings"""
        # Priority: explicit option > compiler.cppstd setting > default
        if hasattr(self.options, 'cxx_standard') and self.options.cxx_standard:
            return str(self.options.cxx_standard)
        
        if hasattr(self.settings.compiler, "cppstd") and self.settings.compiler.cppstd:
            return str(self.settings.compiler.cppstd)
            
        return "20"  # Default fallback
    
    def configure(self):
        if self.settings.os == "Windows":
            self.options.rm_safe("fPIC")
        
        # Determine target C++ standard
        target_cxx_std = self._determine_cxx_standard()
        self.output.info(f"Target C++ standard: C++{target_cxx_std}")
        
        # Set compiler.cppstd if not already set
        if hasattr(self.settings.compiler, "cppstd"):
            if not self.settings.compiler.cppstd:
                self.settings.compiler.cppstd = target_cxx_std
                self.output.info(f"Set compiler.cppstd to {target_cxx_std}")
        
        # Check compiler support for the requested standard
        compiler_name = str(self.settings.compiler)
        compiler_version = str(self.settings.compiler.version)
        
        if not self._check_compiler_support(compiler_name, compiler_version, target_cxx_std):
            min_versions = self._get_min_compiler_version(target_cxx_std)
            min_version = min_versions.get(compiler_name, "unknown")
            
            raise ConanInvalidConfiguration(
                f"{compiler_name} {min_version}+ required for C++{target_cxx_std} support. "
                f"Current version: {compiler_version}. "
                f"Consider using a lower C++ standard or updating your compiler."
            )
        
        self.output.info(f"✓ {compiler_name} {compiler_version} supports C++{target_cxx_std}")
    
    def requirements(self):
        # Core dependencies - these work with C++17+
        self.requires("fmt/10.2.1")
        self.requires("spdlog/1.12.0")
        
        # Optional dependencies based on build type
        if self.settings.build_type == "Debug":
            self.requires("catch2/3.4.0")
    
    def configure_dependencies(self):
        # Configure fmt
        self.options["fmt"].shared = self.options.shared
        
        # Configure spdlog
        self.options["spdlog"].shared = self.options.shared
        if self.settings.build_type == "Debug":
            self.options["spdlog"].no_exceptions = False
    
    def layout(self):
        cmake_layout(self)
    
    def generate(self):
        # Generate CMake files
        deps = CMakeDeps(self)
        deps.generate()
        
        tc = CMakeToolchain(self)
        tc.variables["CMAKE_EXPORT_COMPILE_COMMANDS"] = True
        
        # Set C++ standard in CMake
        target_cxx_std = self._determine_cxx_standard()
        tc.variables["CMAKE_CXX_STANDARD"] = target_cxx_std
        tc.variables["CMAKE_CXX_STANDARD_REQUIRED"] = True
        tc.variables["CMAKE_CXX_EXTENSIONS"] = False
        
        # Add build type specific configurations
        if self.settings.build_type == "Debug":
            tc.variables["CMAKE_BUILD_TYPE"] = "Debug"
            tc.variables["ENABLE_TESTING"] = True
        else:
            tc.variables["CMAKE_BUILD_TYPE"] = "Release"
            tc.variables["ENABLE_TESTING"] = False
                
        tc.generate()
EOF
    
    print_success "Updated conanfile.py with enhanced C++ standard support ✓"
    
    # Update CMakeLists.txt with enhanced version
    print_status "Updating CMakeLists.txt with enhanced C++ standard support..."
    
    cat > CMakeLists.txt << 'EOF'
cmake_minimum_required(VERSION 3.21)

# Project definition with version
project(cpp-conan-template 
    VERSION 1.0.0
    DESCRIPTION "C++ project template with Conan 2.0"
    LANGUAGES CXX
)

# Enhanced C++ standard detection and configuration
function(configure_cpp_standard)
    # Default to C++20 if not specified
    if(NOT DEFINED CMAKE_CXX_STANDARD)
        set(CMAKE_CXX_STANDARD 20)
    endif()
    
    # Ensure we have a valid C++ standard
    set(SUPPORTED_STANDARDS 17 20 23 26)
    if(NOT CMAKE_CXX_STANDARD IN_LIST SUPPORTED_STANDARDS)
        message(WARNING "Unsupported C++ standard: ${CMAKE_CXX_STANDARD}. Falling back to C++20")
        set(CMAKE_CXX_STANDARD 20)
    endif()
    
    # Apply the standard globally
    set(CMAKE_CXX_STANDARD ${CMAKE_CXX_STANDARD} PARENT_SCOPE)
    set(CMAKE_CXX_STANDARD_REQUIRED ON PARENT_SCOPE)
    set(CMAKE_CXX_EXTENSIONS OFF PARENT_SCOPE)
    
    message(STATUS "Using C++${CMAKE_CXX_STANDARD} standard")
endfunction()

# Configure the C++ standard
configure_cpp_standard()

# Enhanced compiler warnings and options
function(configure_compiler_options target)
    # Base warnings for all compilers
    if(MSVC)
        target_compile_options(${target} PRIVATE 
            /W4 /WX-  # High warning level, but don't treat warnings as errors
            /permissive-  # Disable non-conforming code
            /Zc:__cplusplus  # Enable proper __cplusplus macro
        )
        
        # MSVC-specific options for newer C++ standards
        if(CMAKE_CXX_STANDARD GREATER_EQUAL 20)
            target_compile_options(${target} PRIVATE /std:c++20)
        endif()
        if(CMAKE_CXX_STANDARD GREATER_EQUAL 23)
            target_compile_options(${target} PRIVATE /std:c++latest)
        endif()
        
    else()
        # GCC and Clang
        target_compile_options(${target} PRIVATE
            -Wall -Wextra -Wpedantic
            -Wshadow -Wnon-virtual-dtor -Wcast-align -Wunused
            -Woverloaded-virtual -Wconversion -Wsign-conversion
        )
    endif()
    
    # Add debug/release specific options
    target_compile_options(${target} PRIVATE
        $<$<CONFIG:Debug>:-DDEBUG -g -O0>
        $<$<CONFIG:Release>:-DNDEBUG -O3>
        $<$<CONFIG:RelWithDebInfo>:-DNDEBUG -O2 -g>
        $<$<CONFIG:MinSizeRel>:-DNDEBUG -Os>
    )
endfunction()

# Enhanced feature detection for different C++ standards
function(configure_cpp_features target)
    # C++17 features (baseline)
    target_compile_features(${target} PRIVATE cxx_std_17)
    
    # C++20 features
    if(CMAKE_CXX_STANDARD GREATER_EQUAL 20)
        target_compile_features(${target} PRIVATE cxx_std_20)
        target_compile_definitions(${target} PRIVATE 
            CPP_TEMPLATE_HAS_CPP20=1
        )
    endif()
    
    # C++23 features
    if(CMAKE_CXX_STANDARD GREATER_EQUAL 23)
        target_compile_definitions(${target} PRIVATE 
            CPP_TEMPLATE_HAS_CPP23=1
        )
    endif()
    
    # C++26 features (future-proofing)
    if(CMAKE_CXX_STANDARD GREATER_EQUAL 26)
        target_compile_definitions(${target} PRIVATE 
            CPP_TEMPLATE_HAS_CPP26=1
        )
    endif()
endfunction()

# Find dependencies
find_package(fmt REQUIRED)
find_package(spdlog REQUIRED)

# Create main executable
add_executable(${PROJECT_NAME})

# Add source files
target_sources(${PROJECT_NAME} PRIVATE
    src/main.cpp
    src/app.cpp
)

# Add include directories
target_include_directories(${PROJECT_NAME} PRIVATE
    include
    src  # Allow internal headers
)

# Configure C++ features and compiler options
configure_cpp_features(${PROJECT_NAME})
configure_compiler_options(${PROJECT_NAME})

# Link libraries
target_link_libraries(${PROJECT_NAME} PRIVATE 
    fmt::fmt
    spdlog::spdlog
)

# Create interface libraries for common settings (reusable for other targets)
add_library(project_options INTERFACE)
add_library(project_warnings INTERFACE)

# Configure project options
target_compile_features(project_options INTERFACE cxx_std_${CMAKE_CXX_STANDARD})

# Configure warnings based on compiler
if(MSVC)
    target_compile_options(project_warnings INTERFACE /W4)
else()
    target_compile_options(project_warnings INTERFACE 
        -Wall -Wextra -Wpedantic
        -Wshadow -Wnon-virtual-dtor -Wcast-align -Wunused
        -Woverloaded-virtual -Wconversion -Wsign-conversion
    )
endif()

# Link options to main target
target_link_libraries(${PROJECT_NAME} PRIVATE 
    project_options 
    project_warnings
)

# Installation rules
install(TARGETS ${PROJECT_NAME}
    RUNTIME DESTINATION bin
)

# Export compile commands for IDEs
set(CMAKE_EXPORT_COMPILE_COMMANDS ON)

# Print configuration summary
message(STATUS "=== C++ Template Configuration ===")
message(STATUS "C++ Standard: ${CMAKE_CXX_STANDARD}")
message(STATUS "Compiler: ${CMAKE_CXX_COMPILER_ID} ${CMAKE_CXX_COMPILER_VERSION}")
message(STATUS "Build Type: ${CMAKE_BUILD_TYPE}")
message(STATUS "Project Version: ${PROJECT_VERSION}")
message(STATUS "==================================")
EOF
    
    print_success "Updated CMakeLists.txt with enhanced C++ standard support ✓"
}

check_conan_version() {
    local version
    version=$(conan --version 2>/dev/null | cut -d' ' -f3 || echo "0.0.0")
    local major_version
    major_version=$(echo "$version" | cut -d'.' -f1)
    
    if [ "$major_version" != "2" ]; then
        print_error "Conan 2.x is required. Current version: $version"
        print_status "Install with: pip install conan>=2.0"
        return 1
    fi
    
    print_status "Conan $version detected ✓"
    return 0
}

detect_environment() {
    local env_info=()
    
    # Detect OS
    case "$OSTYPE" in
        linux*)   env_info+=("os=Linux") ;;
        darwin*)  env_info+=("os=macOS") ;;
        msys*)    env_info+=("os=Windows/MSYS2") ;;
        cygwin*)  env_info+=("os=Windows/Cygwin") ;;
        *)        env_info+=("os=Unknown") ;;
    esac
    
    # Detect MSYS environment
    if [[ -n "$MSYSTEM" ]]; then
        env_info+=("msys=$MSYSTEM")
    fi
    
    # Detect WSL
    if [[ -n "$WSL_DISTRO_NAME" ]]; then
        env_info+=("wsl=$WSL_DISTRO_NAME")
    fi
    
    # Detect available compilers with versions
    local compilers=()
    if command_exists gcc; then
        local gcc_ver=$(gcc -dumpversion 2>/dev/null | cut -d. -f1)
        compilers+=("gcc-${gcc_ver}")
    fi
    if command_exists clang; then
        local clang_ver=$(clang --version 2>/dev/null | grep -oE '[0-9]+\.[0-9]+' | head -1)
        compilers+=("clang-${clang_ver}")
    fi
    if command_exists cl; then
        compilers+=("msvc")
    fi
    
    if [ ${#compilers[@]} -gt 0 ]; then
        env_info+=("compilers=${compilers[*]}")
    else
        env_info+=("compilers=none")
    fi
    
    printf '%s\n' "${env_info[@]}"
}

clean_dependencies() {
    print_header "Cleaning Development Dependencies"
    
    # Clean legacy configuration dependencies
    if [ -d "$destination" ]; then
        rm -rf "$destination"
        print_status "Removed legacy dependencies from: $destination"
    fi
    
    # Clean Conan cache and profiles
    if command -v conan &> /dev/null; then
        print_status "Cleaning Conan cache..."
        conan cache clean "*" --confirm 2>/dev/null || true
        
        # Clean problematic profiles
        local profile_dir=~/.conan2/profiles
        if [ -d "$profile_dir" ]; then
            print_status "Cleaning Conan profiles..."
            [ -f "$profile_dir/default" ] && rm "$profile_dir/default"
            [ -f "$profile_dir/mingw" ] && rm "$profile_dir/mingw"
            [ -f "$profile_dir/mingw_temp" ] && rm "$profile_dir/mingw_temp"
            [ -f "$profile_dir/msvc" ] && rm "$profile_dir/msvc"
        fi
    fi
    
    # Clean build artifacts
    if [ -d "build" ]; then
        rm -rf build
        print_status "Removed build directory"
    fi
    
    # Clean generated files
    [ -f "run" ] && rm run && print_status "Removed run script"
    [ -f "CMakeUserPresets.json" ] && rm CMakeUserPresets.json
    [ -f ".cppstd" ] && rm .cppstd && print_status "Removed .cppstd file"
    
    # Clean backup files
    [ -f "conanfile.py.backup" ] && rm conanfile.py.backup
    [ -f "CMakeLists.txt.backup" ] && rm CMakeLists.txt.backup
    [ -f "conanfile.py.bak" ] && rm conanfile.py.bak
    [ -f "CMakeLists.txt.bak" ] && rm CMakeLists.txt.bak
    
    print_success "Finished cleaning development dependencies"
}

check_system_requirements() {
    print_header "Checking System Requirements"
    
    local requirements_met=true
    
    # Check Python
    if check_command "python3" || check_command "python"; then
        local python_cmd="python3"
        command_exists python3 || python_cmd="python"
        local python_ver=$($python_cmd --version 2>&1 | grep -oE '[0-9]+\.[0-9]+')
        print_status "Python: $python_ver ✓"
    else
        print_error "Python 3.7+ is required"
        requirements_met=false
    fi
    
    # Check pip
    if check_command "pip3" || check_command "pip"; then
        print_status "pip: available ✓"
    else
        print_error "pip is required for Python package installation"
        requirements_met=false
    fi
    
    # Check C++ compiler
    local compiler_found=false
    if command_exists gcc; then
        local gcc_ver=$(gcc -dumpversion 2>/dev/null | cut -d. -f1)
        if [ "$gcc_ver" -ge 8 ] 2>/dev/null; then
            print_status "GCC: $gcc_ver ✓ (C++20 supported)"
            compiler_found=true
        else
            print_warning "GCC: $gcc_ver (C++20 support limited, recommend GCC 11+)"
            compiler_found=true
        fi
    fi
    
    if command_exists clang; then
        local clang_ver=$(clang --version 2>/dev/null | grep -oE '[0-9]+' | head -1)
        if [ "$clang_ver" -ge 10 ] 2>/dev/null; then
            print_status "Clang: $clang_ver ✓ (C++20 supported)"
            compiler_found=true
        fi
    fi
    
    if command_exists cl; then
        print_status "MSVC: detected ✓ (C++20 supported)"
        compiler_found=true
    fi
    
    if ! $compiler_found; then
        print_error "No suitable C++ compiler found"
        print_status "Required: GCC 8+, Clang 10+, or MSVC 2019+"
        requirements_met=false
    fi
    
    # Check CMake (optional - Conan can provide it)
    if command_exists cmake; then
        local cmake_ver=$(cmake --version 2>/dev/null | head -n1 | grep -oE '[0-9]+\.[0-9]+')
        local cmake_major=$(echo "$cmake_ver" | cut -d. -f1)
        local cmake_minor=$(echo "$cmake_ver" | cut -d. -f2)
        
        if [ "$cmake_major" -gt 3 ] || ([ "$cmake_major" -eq 3 ] && [ "$cmake_minor" -ge 21 ]); then
            print_status "CMake: $cmake_ver ✓"
        else
            print_warning "CMake: $cmake_ver (recommend 3.21+, Conan can provide newer version)"
        fi
    else
        print_warning "CMake not found (Conan will provide it as tool_requires)"
    fi
    
    # Check build tools
    if command_exists ninja; then
        print_status "Ninja: available ✓"
    elif command_exists make; then
        print_status "Make: available ✓"
    else
        print_warning "No build tool found (ninja/make), may need to install"
    fi
    
    if ! $requirements_met; then
        print_error "System requirements not met"
        print_status ""
        print_status "💡 Installation suggestions:"
        print_status "Windows (MSYS2): pacman -S mingw-w64-x86_64-gcc mingw-w64-x86_64-cmake mingw-w64-x86_64-ninja"
        print_status "Ubuntu/Debian: sudo apt install build-essential cmake ninja-build"
        print_status "macOS: brew install cmake ninja"
        exit 1
    fi
    
    print_success "System requirements check passed!"
}

create_modern_mingw_profile() {
    local profile_name="$1"
    
    print_status "Creating modern MinGW profile: $profile_name"
    
    # Detect GCC version and set appropriate C++ standard
    local gcc_version="11"
    local cppstd="20"
    
    if command_exists gcc; then
        local detected_version
        detected_version=$(gcc -dumpversion 2>/dev/null | cut -d. -f1 || echo "11")
        if [ "$detected_version" -ge 8 ] 2>/dev/null; then
            gcc_version="$detected_version"
            if [ "$detected_version" -ge 11 ]; then
                cppstd="20"  # GCC 11+ has full C++20 support
            elif [ "$detected_version" -ge 8 ]; then
                cppstd="17"  # GCC 8-10 has good C++17 support
            fi
        fi
    fi
    
    print_status "Using system GCC $gcc_version with C++$cppstd standard"
    
    mkdir -p ~/.conan2/profiles
    
    cat > ~/.conan2/profiles/"$profile_name" << EOL
[settings]
arch=x86_64
build_type=Release
compiler=gcc
compiler.version=$gcc_version
compiler.libcxx=libstdc++11
compiler.cppstd=$cppstd
os=Windows

[conf]
tools.cmake.cmaketoolchain:generator=Ninja

[buildenv]
CC=gcc
CXX=g++
EOL
    
    print_success "Created modern MinGW profile: $profile_name (C++$cppstd, system tools)"
}

setup_modern_conan_profiles() {
    print_header "Setting Up Modern Conan Profiles"
    
    local environment
    environment=($(detect_environment))
    
    print_status "Environment detection:"
    printf '  %s\n' "${environment[@]}"
    
    # Get compiler info
    local has_gcc=false has_msvc=false has_clang=false
    for info in "${environment[@]}"; do
        if [[ "$info" == "compilers="*"gcc"* ]]; then has_gcc=true; fi
        if [[ "$info" == "compilers="*"msvc"* ]]; then has_msvc=true; fi
        if [[ "$info" == "compilers="*"clang"* ]]; then has_clang=true; fi
    done
    
    # Modern approach: use system tools, no downloads
    if [[ "$OSTYPE" == "msys" || "$OSTYPE" == "cygwin" ]]; then
        # Windows MSYS/Cygwin environment
        print_status "Detected Windows MSYS/Cygwin environment"
        
        if [[ "$MSYSTEM" == "MINGW64" || "$MSYSTEM" == "MINGW32" ]] && $has_gcc; then
            print_status "MINGW environment detected - creating system MinGW profile"
            create_modern_mingw_profile "mingw"
            cp ~/.conan2/profiles/mingw ~/.conan2/profiles/default
            print_status "Set MinGW as default profile (using system tools)"
            
        elif $has_msvc; then
            print_status "MSVC detected - using Conan auto-detection"
            conan profile detect --force
        else
            print_warning "No suitable compiler detected, using Conan auto-detection"
            conan profile detect --force
        fi
        
    else
        # Linux/macOS or other Unix-like systems
        print_status "Detected Unix-like environment"
        
        if [ ! -f ~/.conan2/profiles/default ]; then
            print_status "Creating default profile with auto-detection..."
            conan profile detect --force
        else
            print_status "Default profile already exists"
        fi
    fi
    
    # List created profiles
    print_status "Available Conan profiles:"
    if command -v conan &> /dev/null; then
        conan profile list || true
        
        # Show default profile content
        if [ -f ~/.conan2/profiles/default ]; then
            print_status "Default profile content:"
            cat ~/.conan2/profiles/default | sed 's/^/  /'
        fi
    fi
}

configure_modern_dependencies() {
    print_header "Configuring Modern Development Dependencies"
    start_timer
    
    # Check system requirements first
    check_system_requirements
    
    # Install Python dependencies (packaging, conan)
    install_python_dependencies
    
    # Verify Conan version
    check_conan_version || exit 1
    
    # Setup C++ standard utility script
    setup_cpp_standard_utility
    
    # Update template files with enhanced C++ support
    update_template_files
    
    # Setup modern Conan profiles (no legacy tool downloads)
    setup_modern_conan_profiles
    
    # Set default C++ standard to 20 if not already set
    if [ ! -f ".cppstd" ]; then
        echo "20" > .cppstd
        print_status "Set default C++ standard to C++20"
    fi
    
    # Validate project structure
    print_step "Validating project structure..."
    if ! validate_project_structure; then
        print_warning "Project structure validation failed, but continuing..."
    fi
    
    local setup_time
    setup_time=$(end_timer)
    
    print_header "Modern Configuration Complete!"
    print_success "Setup completed in: $setup_time"
    print_status ""
    print_status "🎯 What was configured:"
    print_status "• Python packaging library (for version comparison)"
    print_status "• Conan 2.0 package manager"
    print_status "• Enhanced C++ standard support (17, 20, 23, 26)"
    print_status "• C++ standard utility script (./scripts/cpp_standard.sh)"
    print_status "• Modern compiler profiles with C++20"
    print_status "• Cross-platform build support"
    print_status ""
    print_status "🚀 Next steps:"
    print_status "1) Run: ./make     (modern build with fallback)"
    print_status "2) Run: ./run      (after successful build)"
    print_status "3) Clean: ./configure clean"
    print_status ""
    print_status "🔧 C++ Standard Management:"
    print_status "• Check current standard: ./scripts/cpp_standard.sh current"
    print_status "• Set C++ standard: ./scripts/cpp_standard.sh set 23"
    print_status "• Check compiler support: ./scripts/cpp_standard.sh check 26"
    print_status "• Show standard info: ./scripts/cpp_standard.sh info 20"
    print_status ""
    print_status "💡 Advantages of enhanced template:"
    print_status "• Fixed version comparison bug (GCC 14 now works!)"
    print_status "• Future-proof C++ standard support"
    print_status "• Better error messages and suggestions"
    print_status "• Easy switching between C++ standards"
    print_status "• Automatic dependency management"
}

# Main script logic
main() {
    print_header "🔧 Modern C++ Conan Template Configuration"
    print_environment_info
    
    # Check for clean argument
    local found_clean=false
    for arg in "$@"; do
        if [[ $arg == *"clean"* ]]; then
            found_clean=true
            break
        fi
    done
    
    if $found_clean; then
        clean_dependencies
    else
        configure_modern_dependencies
    fi
}

# Run main function with all arguments
main "$@"